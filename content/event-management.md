# Event Management

Water Framework provides a comprehensive event system that enables decoupled communication between components through a publish-subscribe pattern. The event system is built on the Core-api interfaces and supports both general application events and entity-specific CRUD events.

## Event System Architecture

The Water Framework event system is based on several core interfaces from the `it.water.core.api.model.events` package:

### Core Event Interfaces

- **`Event`**: Base interface for all events in the framework
- **`ApplicationEventProducer`**: Interface for components that can produce events
- **`ApplicationEventListener`**: Interface for components that can consume events
- **`PreEvent<T>`** and **`PostEvent<T>`**: Interfaces for events that occur before/after operations
- **`PreDetailedEvent<T>`** and **`PostDetailedEvent<T>`**: Interfaces for events with before/after state

## General Application Events

Water Framework supports general application events that can be used for any type of system-wide communication.

### Event Producer Implementation

```java
@FrameworkComponent
public class DocumentEventProducer implements ApplicationEventProducer {
    
    @Override
    public <T extends Resource, K extends Event> void produceEvent(T resource, Class<K> eventClass) {
        // Produce a simple event
        log.info("Producing event {} for resource {}", eventClass.getSimpleName(), resource);
        // Event distribution logic
    }
    
    @Override
    public <T extends Resource, K extends Event> void produceDetailedEvent(T beforeResource, T afterResource, Class<K> eventClass) {
        // Produce a detailed event with before/after state
        log.info("Producing detailed event {} with before/after state", eventClass.getSimpleName());
        // Detailed event distribution logic
    }
}
```

### Event Listener Implementation

```java
@FrameworkComponent
public class DocumentEventListener implements ApplicationEventListener<Document> {
    
    @Override
    public void consumerEvent(Document resource, Event event) {
        log.info("Received event {} for document: {}", event.getClass().getSimpleName(), resource.getTitle());
        
        // Handle the event based on its type
        if (event instanceof DocumentCreatedEvent) {
            handleDocumentCreated(resource);
        } else if (event instanceof DocumentUpdatedEvent) {
            handleDocumentUpdated(resource);
        }
    }
    
    @Override
    public void consumerDetailedEvent(Document beforeResource, Document afterResource, Event event) {
        log.info("Received detailed event {} for document: {} -> {}", 
                event.getClass().getSimpleName(), beforeResource.getTitle(), afterResource.getTitle());
        
        // Handle detailed event with before/after state
        if (event instanceof DocumentUpdatedEvent) {
            handleDocumentUpdatedDetailed(beforeResource, afterResource);
        }
    }
    
    private void handleDocumentCreated(Document document) {
        // Handle document creation event
        // e.g., send notifications, update indexes, etc.
    }
    
    private void handleDocumentUpdated(Document document) {
        // Handle document update event
    }
    
    private void handleDocumentUpdatedDetailed(Document before, Document after) {
        // Handle detailed update with before/after state
        if (!Objects.equals(before.getTitle(), after.getTitle())) {
            log.info("Document title changed from '{}' to '{}'", before.getTitle(), after.getTitle());
        }
    }
}
```

## Entity CRUD Events

**CRUD events are automatically generated by the system for all entity operations.** These events are fired by the framework (e.g., by `BaseEntitySystemServiceImpl`) and are always executed **in the same transaction** as the entity operation. This means that any business logic you attach to these events (such as in a `PreSaveEvent`, `PostUpdateEvent`, etc.) will run within the same database transaction as the original CRUD operation.

> **Warning:** This approach is powerful because it allows you to enforce business rules, validations, and side effects atomically with the main operation. However, it is also risky: if your event listener throws an exception, it will cause the entire transaction to roll back. Use this power carefully and avoid heavy or slow operations in these listeners.

If you need to handle events **outside the transaction** (for example, for eventual consistency, integration with external systems, or to avoid impacting the main transaction), you should use external tools such as Change Data Capture (CDC) solutions.

### Available CRUD Events

The framework provides comprehensive CRUD event interfaces in the `it.water.core.api.entity.events` package:

#### Pre-Operation Events
- **`PreSaveEvent<T>`**: Fired before entity is saved
- **`PreUpdateEvent<T>`**: Fired before entity is updated  
- **`PreRemoveEvent<T>`**: Fired before entity is removed
- **`PreCrudDetailedEvent<T>`**: Base interface for detailed pre-events
- **`PreUpdateDetailedEvent<T>`**: Fired before update with before/after state

#### Post-Operation Events
- **`PostSaveEvent<T>`**: Fired after entity is saved
- **`PostUpdateEvent<T>`**: Fired after entity is updated
- **`PostRemoveEvent<T>`**: Fired after entity is removed
- **`PostCrudDetailedEvent<T>`**: Base interface for detailed post-events
- **`PostUpdateDetailedEvent<T>`**: Fired after update with before/after state

### CRUD Event Implementation

```java
@FrameworkComponent
public class DocumentPreSaveListener implements PreSaveEvent<Document> {
    
    @Override
    public void execute(Document entity) {
        log.info("Document {} is about to be saved", entity.getTitle());
        
        // Pre-save validation or business logic
        if (entity.getFileSize() != null && entity.getFileSize() > 10000000) {
            throw new BusinessException("File size too large for saving");
        }
        
        // Set default values
        if (entity.getCreatedDate() == null) {
            entity.setCreatedDate(new Date());
        }
    }
}

@FrameworkComponent
public class DocumentPostSaveListener implements PostSaveEvent<Document> {
    
    @Override
    public void execute(Document entity) {
        log.info("Document {} has been saved with ID {}", entity.getTitle(), entity.getId());
        
        // Post-save operations
        // e.g., send notifications, update search indexes, etc.
        sendDocumentCreatedNotification(entity);
        updateSearchIndex(entity);
    }
    
    private void sendDocumentCreatedNotification(Document document) {
        // Send notification logic
    }
    
    private void updateSearchIndex(Document document) {
        // Update search index logic
    }
}

@FrameworkComponent
public class DocumentPreUpdateListener implements PreUpdateEvent<Document> {
    
    @Override
    public void execute(Document entity) {
        log.info("Document {} is about to be updated", entity.getTitle());
        
        // Pre-update validation
        validateUpdatePermissions(entity);
    }
    
    private void validateUpdatePermissions(Document document) {
        // Permission validation logic
    }
}

@FrameworkComponent
public class DocumentPostUpdateListener implements PostUpdateEvent<Document> {
    
    @Override
    public void execute(Document entity) {
        log.info("Document {} has been updated", entity.getTitle());
        
        // Post-update operations
        updateSearchIndex(entity);
        sendDocumentUpdatedNotification(entity);
    }
}

@FrameworkComponent
public class DocumentPreRemoveListener implements PreRemoveEvent<Document> {
    
    @Override
    public void execute(Document entity) {
        log.info("Document {} is about to be removed", entity.getTitle());
        
        // Pre-remove validation
        validateRemovalPermissions(entity);
        
        // Cleanup operations
        cleanupRelatedResources(entity);
    }
    
    private void validateRemovalPermissions(Document document) {
        // Permission validation logic
    }
    
    private void cleanupRelatedResources(Document document) {
        // Cleanup logic
    }
}
```

### Detailed Events with Before/After State

For operations that modify entities, Water Framework provides detailed events that include both the before and after state:

```java
@FrameworkComponent
public class DocumentPreUpdateDetailedListener implements PreUpdateDetailedEvent<Document> {
    
    @Override
    public void execute(Document beforeEntity, Document afterEntity) {
        log.info("Document update from '{}' to '{}'", beforeEntity.getTitle(), afterEntity.getTitle());
        
        // Compare before/after state
        if (!Objects.equals(beforeEntity.getTitle(), afterEntity.getTitle())) {
            log.info("Title changed from '{}' to '{}'", beforeEntity.getTitle(), afterEntity.getTitle());
        }
        
        if (!Objects.equals(beforeEntity.getFileSize(), afterEntity.getFileSize())) {
            log.info("File size changed from {} to {}", beforeEntity.getFileSize(), afterEntity.getFileSize());
        }
        
        // Pre-update business logic with before/after context
        validateTitleChange(beforeEntity, afterEntity);
    }
    
    private void validateTitleChange(Document before, Document after) {
        // Business logic for title changes
        if (before.getTitle().contains("confidential") && !after.getTitle().contains("confidential")) {
            throw new BusinessException("Cannot remove 'confidential' from document title");
        }
    }
}

@FrameworkComponent
public class DocumentPostUpdateDetailedListener implements PostUpdateDetailedEvent<Document> {
    
    @Override
    public void execute(Document beforeEntity, Document afterEntity) {
        log.info("Document updated from '{}' to '{}'", beforeEntity.getTitle(), afterEntity.getTitle());
        
        // Post-update operations with before/after context
        if (!Objects.equals(beforeEntity.getTitle(), afterEntity.getTitle())) {
            updateSearchIndex(afterEntity);
            sendTitleChangeNotification(beforeEntity, afterEntity);
        }
        
        if (!Objects.equals(beforeEntity.getFileSize(), afterEntity.getFileSize())) {
            updateStorageQuota(beforeEntity, afterEntity);
        }
    }
    
    private void sendTitleChangeNotification(Document before, Document after) {
        // Notification logic for title changes
    }
    
    private void updateStorageQuota(Document before, Document after) {
        // Storage quota update logic
    }
}
```

## Best Practices

- **Keep event listeners lightweight**: Avoid heavy or slow operations in in-transaction listeners.
- **Handle exceptions carefully**: Any exception will roll back the transaction.
- **For out-of-transaction/eventual consistency, use external tools**: If you need to react to changes without impacting the main transaction, consider using CDC or similar mechanisms.

This event management system provides Water Framework applications with a powerful, decoupled communication mechanism that supports both general application events and automatic CRUD event generation, with the flexibility to choose between in-transaction and out-of-transaction event handling as needed. 